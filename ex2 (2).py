# -*- coding: utf-8 -*-
"""Ex2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BX5gAPrcXhmmXVbGV7fXp7wPMHXf2BZE
"""

!pip install scikit-fuzzy deap matplotlib

import numpy as np
import skfuzzy as fuzz
from skfuzzy import control as ctrl
from deap import base, creator, tools
import random
import matplotlib.pyplot as plt

angle = ctrl.Antecedent(np.arange(-180, 181, 1), 'angle')
velocity = ctrl.Antecedent(np.arange(-10, 11, 1), 'velocity')
force = ctrl.Consequent(np.arange(-10, 11, 1), 'force')

angle['neg'] = fuzz.trimf(angle.universe, [-180, -180, 0])
angle['zero'] = fuzz.trimf(angle.universe, [-180, 0, 180])
angle['pos'] = fuzz.trimf(angle.universe, [0, 180, 180])

velocity['neg'] = fuzz.trimf(velocity.universe, [-10, -10, 0])
velocity['zero'] = fuzz.trimf(velocity.universe, [-10, 0, 10])
velocity['pos'] = fuzz.trimf(velocity.universe, [0, 10, 10])

force['neg'] = fuzz.trimf(force.universe, [-10, -10, 0])
force['zero'] = fuzz.trimf(force.universe, [-10, 0, 10])
force['pos'] = fuzz.trimf(force.universe, [0, 10, 10])

rule1 = ctrl.Rule(angle['neg'] & velocity['neg'], force['pos'])
rule2 = ctrl.Rule(angle['neg'] & velocity['zero'], force['pos'])
rule3 = ctrl.Rule(angle['neg'] & velocity['pos'], force['zero'])
rule4 = ctrl.Rule(angle['zero'] & velocity['neg'], force['pos'])
rule5 = ctrl.Rule(angle['zero'] & velocity['zero'], force['zero'])
rule6 = ctrl.Rule(angle['zero'] & velocity['pos'], force['neg'])
rule7 = ctrl.Rule(angle['pos'] & velocity['neg'], force['zero'])
rule8 = ctrl.Rule(angle['pos'] & velocity['zero'], force['neg'])
rule9 = ctrl.Rule(angle['pos'] & velocity['pos'], force['neg'])

pendulum_ctrl = ctrl.ControlSystem([rule1, rule2, rule3, rule4, rule5, rule6, rule7, rule8, rule9])
pendulum_sim = ctrl.ControlSystemSimulation(pendulum_ctrl)

try:
    del creator.FitnessMax
    del creator.Individual
except:
    pass

creator.create("FitnessMax", base.Fitness, weights=(1.0,))
creator.create("Individual", list, fitness=creator.FitnessMax)

def evaluate(individual):
    pendulum_sim.input['angle'] = random.uniform(-180, 180)
    pendulum_sim.input['velocity'] = random.uniform(-10, 10)
    pendulum_sim.compute()

    return (pendulum_sim.output['force'],)

toolbox = base.Toolbox()
toolbox.register("individual", tools.initIterate, creator.Individual, lambda: random.sample(range(1, 10), 3))
toolbox.register("population", tools.initRepeat, list, toolbox.individual)
toolbox.register("evaluate", evaluate)
toolbox.register("mate", tools.cxBlend, alpha=0.5)
toolbox.register("mutate", tools.mutGaussian, mu=0, sigma=1, indpb=0.2)
toolbox.register("select", tools.selTournament, tournsize=3)

population = toolbox.population(n=50)
fitness_history = []

for gen in range(50):
    fitnesses = list(map(toolbox.evaluate, population))
    for ind, fit in zip(population, fitnesses):
        ind.fitness.values = fit

    fitness_history.append(max(fit[0] for fit in fitnesses))

plt.plot(fitness_history)
plt.title("Desempenho da População ao Longo das Gerações")
plt.xlabel("Gerações")
plt.ylabel("Fitness Máximo")
plt.grid()
plt.show()